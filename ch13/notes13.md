# 第13章 拷贝控制

当定义一个类时，我们显式地或隐式地指定在此类型地对象拷贝、移动、赋值和销毁时做什么。一个类通过以下五种特殊地成员函数来控制这些操作，我们称这些操作为拷贝控制操作

1. 拷贝构造函数
2. 拷贝赋值运算符
3. 移动构造函数
4. 移动赋值运算符
5. 析构函数

## 13.1 拷贝、赋值与销毁

从最基本的操作——拷贝构造函数、拷贝赋值运算符和析构函数作为开始。

### 拷贝构造函数

拷贝构造函数的第一个参数必须是引用类型。拷贝构造函数通常不应该是`explicit`的。

```cpp
class Foo
{
public:
    Foo();            // 默认构造函数
    Foo(const Foo &); // 拷贝构造函数
};
```

### 合成拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。 对于某些类来说，合成的版本无法正常工作（239页）

此函数会将参数的成员逐个拷贝到正在创建的对象中。

```cpp
string dots(10, '.');	// 直接初始化
string s(dots);			// 直接初始化
string s2 = dots;	// 拷贝初始化
string null_book = "9-999-99999-9";	// 拷贝初始化
string nines = string(100, '9';)	// 拷贝初始化
```

当使用直接初始化时，实际上是要求编译器使用普通的函数匹配（209页）来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化时，是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还需要进行类型转换。（263页）

### 拷贝初始化

不仅在我们用`=`定义变量时会发生，下列情况也会发送

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（266页）

编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象

```cpp
string null_book = "9-999-99999-9";	// 拷贝初始化
string null_book("9-999-99999-9");	// 编译器略过了拷贝构造函数
```

### 拷贝赋值运算符

如果类没有定义自己的拷贝赋值运算符，编译器会为其合成一个。

- 重载赋值运算符

首先要了解一些重载运算符的知识。重载运算符本质上是函数，其名字由`operator`关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为`operator=`的函数。

拷贝赋值运算符接受一个与其所在类相同类型的参数：

```cpp
class Foo
{
public:
    Foo &operator=(const Foo &); // 赋值运算符
};
```

赋值运算符通常应该返回一个指向其左侧运算对象的引用

- 合成拷贝赋值运算符

将右侧运算对象的每个非`static`赋予左侧运算对象的对应成员

```cpp
Sales_data &Sales_data::operator=(const Sales_data &rhs)
{
    bookNo = rhs.bookNo;
    units_sold = rhs.units_sold;
    revenue = rhs.revenue;
    return *this;
}
```



### 析构函数

- 析构函数执行与构造函数相反的操作：

  - 构造函数初始化对象的非`static`数据成员，还可能做一些其他工作

  - 析构函数释放对象使用的资源，并销毁对象的非`static`数据成员

析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。

```cpp
class Foo
{
public:
    ~Foo(); // 析构函数
};
```

- 什么时候会调用析构函数？无论何时一个对象被销毁，就会自动调用析构函数

  - 变量在离开其作用域时被销毁
  - 当一个对象被销毁时，其成员被销毁

  - 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁

  - 对于动态分配的对象，当指向它的指针应用`delete`运算符时被销毁（409页）

  - 对于临时对象，当创建它的完整表达式结束时被销毁

当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

- 合成析构函数
  - 空函数体执行完后，成员会被自动销毁
  - 析构函数体本身并不直接销毁成员
  - 合成析构函数不会`delete`一个指针的数据成员。

### 三/五法则

当我们决定一个类是否要定义自己版本的拷贝控制成员时，参考下面两个原则

- 如果这个类需要一个析构函数，几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符
- 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。

补充：合成析构函数无法`delete`一个指针的数据成员，所以当需要释放动态分配的内存时，需要定义析构函数。



### 使用=default

- 可以通过拷贝控制成员定义为`=default`来显式地要求编译器生成合成地版本
- 合成地函数将隐式地声明为内联的

我们只能对具有合成版本的成员函数使用`=default`（即，默认构造函数或拷贝控制成员）

### 阻止拷贝

注意：大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地

- 定义删除的函数

  - 通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝
  - 删除的函数：虽然声明了，但是不能以任何方式使用它们
  - 在函数的参数列表后面加上`=delete`来指出我们希望将它定义为删除的

  ```cpp
  struct NoCopy
  {
      NoCopy() = default;                         // 使用合成的默认构造函数
      NoCopy(const NoCopy &) = delete;            // 阻止拷贝
      NoCopy &operator=(const NoCopy &) = delete; // 阻止赋值
      ~NoCopy() = default;                        // 使用合成的析构函数
  };
  ```

  - 与`=default`不同，`=delete`必须出现在函数第一次声明的时候
  - 与`=default`的另一个不同，我们可以对任何函数指定`=delete`（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用`=default`）

- 析构函数不能是删除的成员

```cpp
struct NoDtor
{
    NoDtor() = default; // 使用合成的默认构造函数
    ~NoDtor() = delete; // 我们不能销毁NoDtor类型的对象
};
NoDtor nd;                // 错误：NoDtor的析构函数是删除的
NoDtor *p = new NoDtor(); // 正确：但我们不能delete p
delete p;                 // 错误：NoDtor的析构函数是删除的
```

- 合成的拷贝控制成员可能是删除的
- 如果一个类有数据成员不能默认构造、拷贝、赋值或者销毁，则对应的成员函数将被定义为删除的
- 老版本使用`private`声明来阻止拷贝

## 13.2 拷贝控制和资源管理

一旦一个类需要析构函数，那么几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说有两种选择：可以定义拷贝操作，使类的行为看起来更像一个值或者一个指针

- 行为像一个值：当我们拷贝一个对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。
- 行为像指针：共享状态，当我们拷贝一个这种类的对象时，副本和对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

### 行为像值得类

```cpp
HasPtr &operator=(const HasPtr &hp)	// 本例参考书本453页和练习题13.22
{
    auto newp = new string(*hp.ps); // 拷贝底层string
    delete ps;                      // 释放旧内存
    ps = newp;                      // 从右侧运算符对象拷贝数据到本对象
    i = hp.i;
    return *this; // 返回本对象
}
```

编写赋值运算符时，需要记住两点：

- 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
- 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

编写一个赋值运算符时，一个好的模式是先将右侧运算符对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

### 行为像指针的类



## 13.3 交换操作

- 与拷贝控制成员不同，`swap`并不是必要的。但是，对于分配了资源的类，定义`swap`可能是一种很重要的优化手段。

- `swap`函数应该调用`swap`，而不是`std::swap`



## 13.4 拷贝控制示例

拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。这种情况下，公共的工作应该放在`private`的工具函数中完成。

（这一节看的莫名其妙，可能是晚上精神不好？）



## 13.5 动态内存管理类

某些类需要在运行时分配可变大小的内存空间。这种类使用标准库来保存他们的数据。但是这一策略并不是对每个类都适用，有些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。



（本章暂时结束）















































