# 第13章 拷贝控制

当定义一个类时，我们显式地或隐式地指定在此类型地对象拷贝、移动、赋值和销毁时做什么。一个类通过以下五种特殊地成员函数来控制这些操作，我们称这些操作为拷贝控制操作

1. 拷贝构造函数
2. 拷贝赋值运算符
3. 移动构造函数
4. 移动赋值运算符
5. 析构函数

## 13.1 拷贝、赋值与销毁

从最基本的操作——拷贝构造函数、拷贝赋值运算符和析构函数作为开始。

### 拷贝构造函数

拷贝构造函数的第一个参数必须是引用类型。拷贝构造函数通常不应该是`explicit`的。

```cpp
class Foo
{
public:
    Foo();            // 默认构造函数
    Foo(const Foo &); // 拷贝构造函数
};
```

### 合成拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。 对于某些类来说，合成的版本无法正常工作（239页）

此函数会将参数的成员逐个拷贝到正在创建的对象中。

```cpp
string dots(10, '.');	// 直接初始化
string s(dots);			// 直接初始化
string s2 = dots;	// 拷贝初始化
string null_book = "9-999-99999-9";	// 拷贝初始化
string nines = string(100, '9';)	// 拷贝初始化
```

当使用直接初始化时，实际上是要求编译器使用普通的函数匹配（209页）来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化时，是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还需要进行类型转换。（263页）

### 拷贝初始化

不仅在我们用`=`定义变量时会发生，下列情况也会发送

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（266页）

编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象

```cpp
string null_book = "9-999-99999-9";	// 拷贝初始化
string null_book("9-999-99999-9");	// 编译器略过了拷贝构造函数
```

### 拷贝赋值运算符

如果类没有定义自己的拷贝赋值运算符，编译器会为其合成一个。

- 重载赋值运算符

首先要了解一些重载运算符的知识。重载运算符本质上是函数，其名字由`operator`关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为`operator=`的函数。

拷贝赋值运算符接受一个与其所在类相同类型的参数：

```cpp
class Foo
{
public:
    Foo &operator=(const Foo &); // 赋值运算符
};
```

赋值运算符通常应该返回一个指向其左侧运算对象的引用

- 合成拷贝赋值运算符

将右侧运算对象的每个非`static`赋予左侧运算对象的对应成员

```cpp
Sales_data &Sales_data::operator=(const Sales_data &rhs)
{
    bookNo = rhs.bookNo;
    units_sold = rhs.units_sold;
    revenue = rhs.revenue;
    return *this;
}
```



### 析构函数

- 析构函数执行与构造函数相反的操作：

  - 构造函数初始化对象的非`static`数据成员，还可能做一些其他工作

  - 析构函数释放对象使用的资源，并销毁对象的非`static`数据成员

析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。

```cpp
class Foo
{
public:
    ~Foo(); // 析构函数
};
```

- 什么时候会调用析构函数？无论何时一个对象被销毁，就会自动调用析构函数

  - 变量在离开其作用域时被销毁
  - 当一个对象被销毁时，其成员被销毁

  - 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁

  - 对于动态分配的对象，当指向它的指针应用`delete`运算符时被销毁（409页）

  - 对于临时对象，当创建它的完整表达式结束时被销毁

当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

- 合成析构函数
  - 空函数体执行完后，成员会被自动销毁
  - 析构函数体本身并不直接销毁成员
  - 合成析构函数不会`delete`一个指针的数据成员。

### 三/五法则

当我们决定一个类是否要定义自己版本的拷贝控制成员时，参考下面两个原则

- 如果这个类需要一个析构函数，几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符
- 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。

补充：合成析构函数无法`delete`一个指针的数据成员，所以当需要释放动态分配的内存时，需要定义析构函数。



### 使用=default

- 可以通过拷贝控制成员定义为`=default`来显式地要求编译器生成合成地版本
- 合成地函数将隐式地声明为内联的

我们只能对具有合成版本的成员函数使用`=default`（即，默认构造函数或拷贝控制成员）

### 阻止拷贝

注意：大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地

- 定义删除的函数