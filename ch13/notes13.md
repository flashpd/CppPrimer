# 第13章 拷贝控制

当定义一个类时，我们显式地或隐式地指定在此类型地对象拷贝、移动、赋值和销毁时做什么。一个类通过以下五种特殊地成员函数来控制这些操作，我们称这些操作为拷贝控制操作

1. 拷贝构造函数
2. 拷贝赋值运算符
3. 移动构造函数
4. 移动赋值运算符
5. 析构函数

## 13.1 拷贝、赋值与销毁

从最基本的操作——拷贝构造函数、拷贝赋值运算符和析构函数作为开始。

### 拷贝构造函数

拷贝构造函数的第一个参数必须是引用类型。拷贝构造函数通常不应该是`explicit`的。

```cpp
class Foo
{
public:
    Foo();            // 默认构造函数
    Foo(const Foo &); // 拷贝构造函数
};
```

### 合成拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。 对于某些类来说，合成的版本无法正常工作（239页）

此函数会将参数的成员逐个拷贝到正在创建的对象中。

```cpp
string dots(10, '.');	// 直接初始化
string s(dots);			// 直接初始化
string s2 = dots;	// 拷贝初始化
string null_book = "9-999-99999-9";	// 拷贝初始化
string nines = string(100, '9';)	// 拷贝初始化
```

当使用直接初始化时，实际上是要求编译器使用普通的函数匹配（209页）来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化时，是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还需要进行类型转换。（263页）

### 拷贝初始化

不仅在我们用`=`定义变量时会发生，下列情况也会发送

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（266页）

编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象

```cpp
string null_book = "9-999-99999-9";	// 拷贝初始化
string null_book("9-999-99999-9");	// 编译器略过了拷贝构造函数
```

### 拷贝赋值运算符

如果类没有定义自己的拷贝赋值运算符，编译器会为其合成一个。

- 重载赋值运算符

首先要了解一些重载运算符的知识。重载运算符本质上是函数，其名字由`operator`关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为`operator=`的函数。

拷贝赋值运算符接受一个与其所在类相同类型的参数：

```cpp
class Foo
{
public:
    Foo &operator=(const Foo &); // 赋值运算符
};
```

赋值运算符通常应该返回一个指向其左侧运算对象的引用

- 合成拷贝赋值运算符

将右侧运算对象的每个非`static`赋予左侧运算对象的对应成员

```cpp
Sales_data &Sales_data::operator=(const Sales_data &rhs)
{
    bookNo = rhs.bookNo;
    units_sold = rhs.units_sold;
    revenue = rhs.revenue;
    return *this;
}
```



### 析构函数

析构函数执行与构造函数相反的操作：

- 构造函数初始化对象的非`static`数据成员，还可能做一些其他工作
- 析构函数释放对象使用的资源，并销毁对象的非`static`数据成员

析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。

```cpp
class Foo
{
public:
    ~Foo(); // 析构函数
};

```



