# 第十一章 关联容器

关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是`map`和`set`。

| 关联容器类型 |                                  |
| ------------ | -------------------------------- |
| map          | 关联数组：保存关键字-值对        |
| set          | 关键字即值，即只保存关键字的容器 |
| multimap     | 关键字可重复出现的map            |
| multiset     | 关键字可重复出现的set            |

| 无序集合           |                                   |
| ------------------ | --------------------------------- |
| unordered_map      | 用哈希函数组织的map               |
| unordered_set      | 用哈希函数组织的set               |
| unordered_multimap | 哈希组织的map：关键字可以重复出现 |
| unordered_multiset | 哈希组织的set：关键字可以重复出现 |

## 11.2 关联容器概述

### 关键字类型的要求

无论我们怎么定义比较函数，它都必须具备如下基本性质：

- 两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2绝不能“小于等于”k1.
- 如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3。
- 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价于”k2，且k2“等价于”k3，那么k1必须“等价于”k3。

如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将提摩太视作相等来处理。当用作`map`的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。

### pair类型

定义在头文件`utility`中

| pair操作               |                                                              |
| ---------------------- | ------------------------------------------------------------ |
| pair<T1, T2> p         | p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化      |
| pair<T1, T2> p(v1, v2) | p是一个成员类型为T1和T2的pair；first和second成员分布用v1和v2初始化 |
| pair<T1, T2>p={v1, v2} | 同上                                                         |
| make_pair(v1, v2)      | 返回一个用v1和v2初始化的pair。pair的类型从v1和v2类型推断出来 |
| p.first                | 返回p的名为first的（公有）数据成员                           |
| p.second               | 返回p的名为second的（公有）数据成员                          |
| p1 relop p2            | 关系运算符（<、>、<=、>=）按字典顺序                         |
| p1 == p2               | 当first和second成员分别相等时，两个pair相等。相等性判断利用元素的==运算符实现 |
| p1 != p2               | 同上                                                         |



### 11.3 关联容器操作

| 类型别名    |                                                              |
| ----------- | ------------------------------------------------------------ |
| key_type    | 此容器的关键字类型                                           |
| mapped_type | 每个关键字关联的类型；只适用于map                            |
| value_type  | 对于set，与key_type相同，                                                                                     对于map，为pair<const key_type, mapped_type> |

### 关联容器迭代器

必须记住，一个map的`value_type`是一个pair，我们可以改变`pair`的值，但不能改变关键字成员的值。

`set`的迭代器是`const`的

### 添加元素

向一个`map`进行`insert`操作时，必须记住元素类型是`pair`。

```cpp
word_count.insert({word, 1});
word_count.insert(make_pair(word, 1));
word_count.insert(pair<string, size_t>(word, 1));
word_count.insert(map<string, size_t>::value_type(word, 1));
```

| 关联容器的insert操作 |                                                              |
| -------------------- | ------------------------------------------------------------ |
| c.insert(v)          | v是value_type类型的对象；args用来构造一个元素                |
| c.emplace(args)      | 对于map和set，只有当元素的关键字不在c中时才插入（或构造）元素。函数返回一个pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的bool值。对于multimap和multiset，总会插入（或构造）给定元素，并返回一个指向新元素的迭代器 |
| c.insert(b, e)       | b和e是迭代器，表示一个c::value_type类型值得范围；il是这种值得花括号列表。函数返回void。对于map和set，只插入关键字不在c中得元素。对于multimap和multiset，则会插入范围中得每个元素 |
| c.insert(il)         | 同上                                                         |
| c.insert(p, v)       | 类似insert(v)（或emplace(args)），但将迭代器p作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素 |

### 删除元素

| 从关联容器删除元素 |                                                              |
| ------------------ | ------------------------------------------------------------ |
| c.erase(k)         | 从c中删除每个关键字为k的元素。返回一个size_type值，指出删除的元素的数量 |
| c.erase(p)         | 从c中删除迭代器p指定的元素。p必须指向c中一个真实元素，不能等于c.end()。返回一个指向p之后元素的迭代器，若p指向c中的尾元素，则返回c.end() |
| c.erase(b,e)       | 删除迭代器对b和e所表示范围中的元素，返回e。                  |

### map的下标操作

对一个`map`使用下标操作，其行为与数组或`vector`上的下标操作很不相同：使用一个不在容器中的关键字作为下标，会添加一个具有此关键字的元素到`map`中。

| map和unordered_map |                                                              |
| ------------------ | ------------------------------------------------------------ |
| c[k]               | 返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化 |
| c.at[k]            | 访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常（参见5.6节，第173页） |

### 访问元素

| 在关联容器中查找元素 |                                                              |
| -------------------- | ------------------------------------------------------------ |
| c.find(k)            | 返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器 |
| c.count(k)           | 返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0是1 |
| c.lower_bound(k)     | 返回一个迭代器，指向第一个关键字不小于k的元素                |
| c.upper_bound(k)     | 返回一个迭代器，指向第一个关键字大于k的元素                  |
| c.equal_range(k)     | 返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存在，pair的两个成员均等于e.end() |

- `lower_bound`和`upper_bound`不适用于无序容器
- 下标和`at`操作只适用于非`const`的`map`和`unordered_map`
- `lower_bound`返回的迭代器可能指向一个具有给定关键字的元素，但也可能不知向。如果关键字不在容器中，则`lower_bound`会返回关键字的第一个安全插入点（不影响容器中元素顺序的插入位置）
- 如果`lower_bound`和`upper_bound`返回相同的迭代器，则给定关键字不在容器中



## 11.4 无序容器

如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。

无序容器管理操作		

| 桶接口               |                            |
| -------------------- | -------------------------- |
| c.bucket_count()     | 正在使用的桶的数目         |
| c.max_bucket_count() | 容器能容纳的最多的桶的数量 |
| c.bucket_size(n)     | 第n个桶中有多少个元素      |
| c.bucket(k)          | 关键字为k的元素在哪个桶中  |

| 桶迭代                 |                                              |
| ---------------------- | -------------------------------------------- |
| local_iterator         | 可以用来访问桶中元素的迭代器类型             |
| const_local_iterator   | 桶迭代器的const版本                          |
| c.begin(n), c.end(n)   | 桶n的首元素迭代器和尾后迭代器                |
| c.cbegin(n), c.cend(n) | 与前两个函数类似，但返回const_local_iterator |

| 哈希策略            |                                                              |
| ------------------- | ------------------------------------------------------------ |
| c.load_factor()     | 每个桶的平均元素数量，返回float值                            |
| c.max_load_factor() | c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，以使得load_factor<=max_load_factor |
| c.rehash(n)         | 重组存储，使得bucket_count>=n 且bucket_count>size/max_bucket_count |
| c.reserve(n)        | 重组存储，使得c可以保存n个元素且不必rehash                   |

