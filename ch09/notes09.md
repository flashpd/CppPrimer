# 第九章 顺序容器

## 9.1 顺序容器概述

| 类型         | 功能                                                         |
| ------------ | ------------------------------------------------------------ |
| vector       | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 |
| deque        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快      |
| list         | 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快 |
| forward_list | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 |
| array        | 固定大小数组。支持快速随机访问。不能添加或删除元素           |
| string       | 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 |

选择容器的基本原则：

1. 除非你有更好的理由选择其他容器，否则应使用`vector`。
2. 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`。
3. 如果要求随机访问元素，应使用`vector`或`deque`。
4. 如果程序需要在头尾位置插入或删除元素，但不会在中间的位置插入或删除操作，则使用`deque`。
5. 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素则
   - 首先，确定是否真的需要在容器中间位置添加元素。当处理数据时，通常很容易地向`vector`追加数据，然后再调用标准库的`sort`函数。
   - 如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

如果不确定应该使用哪种容器，那么可以在程序中只使用`vector`和`list`公共操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用`vector`或`list`都很方便。



## 9.2 容器库概览

| 类型别名        |                                                        |
| --------------- | ------------------------------------------------------ |
| iterator        | 此容器类型的迭代器                                     |
| const_iterator  | 可以读取元素，但不能修改元素的迭代器类型               |
| size_type       | 无符号整数类型，足够保存此类容器类型最大可能容器的大小 |
| difference_type | 带符号整数类型，足够保存两个迭代器之间的距离           |
| value_type      | 元素类型                                               |
| reference       | 元素左值类型，与value_type&含义相同                    |
| const_reference | 元素的const左值类型，(即，const value_type&)           |



| 构造函数        |                                                         |
| --------------- | ------------------------------------------------------- |
| C c             | 默认构造函数，构造空容器                                |
| C c1(c2)        | 构造c2的拷贝c1                                          |
| C c(b, e)       | 构造c，将迭代器b和e指定的范围内元素拷贝到c(array不支持) |
| C c{a, b, c...} | 列表初始化c                                             |



| 赋值与swap        |                              |
| ----------------- | ---------------------------- |
| c1=c2             | 将c1中的元素替换为c2中元素   |
| c1 = {a, b, c...} | 将c1中的元素替换为列表中元素 |
| a.swap(b)         | 交换a和b的元素               |
| swap(a, b)        | 与a.swap(b)等价              |



| 大小         |                                          |
| ------------ | ---------------------------------------- |
| c.size()     | c中元素的数目(不支持forward_list)        |
| c.max_size() | c可保存的最大元素数目                    |
| c.empty()    | 若c中存储了元素，返回false，否则返回true |



| 添加/删除元素(不适用与array) | 注：在不同容器中，这些操作的接口都不同 |
| ---------------------------- | -------------------------------------- |
| c.insert(args)               | 将args中的元素拷贝进c                  |
| c.emplace(inits)             | 使用inits构造c中的一个元素             |
| c.erase(args)                | 删除args指定的元素                     |
| c.clear()                    | 删除c中的所有元素，返回void            |
| 关系运算符                   |                                        |
| ==, !=                       | 所有容器都支持相等(不等)运算符         |
| <, <=, >, >=                 | 关系运算符(无序关联容器不支持)         |



| 获取迭代器             |                                           |
| ---------------------- | ----------------------------------------- |
| c.begin(), c.end()     | 返回指向c的首元素和尾元素之后位置的迭代器 |
| c.cbegin(), c.cend()   | 返回const_iterator                        |
| 反向容器的额外成员     | 不支持forward_list                        |
| reverse_iterator       | 按逆序寻址元素的迭代器                    |
| const_reverse_iterator | 不能修改元素的逆序迭代器                  |
| c.rbegin(), c.rend()   | 返回指向c的尾元素和首元素之前位置的迭代器 |
| c.crbegin(), c.crend() | 返回const_reverse_iterator                |

### 迭代器

左闭右开

| 容器定义和初始化 |                                                              |
| ---------------- | ------------------------------------------------------------ |
| C c              | 默认构造函数。如果C是一个array，则c中元素按默认方式初始化；否则c为空 |
| C c1(c2)         | c1初始化为c2的拷贝。c1和c2必须是相同类型，如果是array类型还必须相同大小 |
| C c{a, b, c...}  | c初始化为初始化列表中元素的拷贝。对于array类型，列表中元素数目必须小于或等于array的大小，任何遗漏的元素都进行值初始化 |
| C c={a, b, c...} | 同上                                                         |
| C c(b, e)        | c初始化为迭代器b和e指定范围中的元素的拷贝。array不适用       |
| C seq(n)         | seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的 |
| C seq(n, t)      | seq包含n个初始化为值t的元素                                  |

只有顺序容器(不包括array)的构造函数才能接受大小参数



| 容器赋值运算     |                                                              |
| ---------------- | ------------------------------------------------------------ |
| c1=c2            | 将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型   |
| c={a, b, c...}   | 将c1中元素替换为初始化列表中元素的拷贝(array不适用)          |
| swap(c1, c2)     | 交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多 |
| c1.swap(c2)      |                                                              |
|                  | assign操作不适用与关联容器和array                            |
| seq.assign(b, e) | 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素 |
| seq.assign(il)   | 将seq中的元素替换为初始化列表il中的元素                      |
| seq.assign(n, t) | 将seq中的元素替换为n个值为t的元素                            |

赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而`swap`操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效(容器类型为`array`和`string`的情况除外)



### 容器大小操作

- 成员函数`size`返回容器中元素的数目
- `empty`当`size`为0时返回布尔值`true`，否则返回`false`
- `max_size`返回一个大于或等于该类型容器所能容纳的最大元素数的值
- `forward_list`支持`max_size`和`empty`，但不支持`size`



## 9.3 顺序容器操作

| 操作                  | 解释                                                         |
| --------------------- | ------------------------------------------------------------ |
| c.push_back(t)        | 在c的尾部创建一个值为t或由args创建的元素。返回void           |
| c.emplace_back(args)  | 同上                                                         |
| c.push_front(t)       | 在c的头部创建一个值为t或由args创建的元素。返回void           |
| c.emplace_front(args) | 同上                                                         |
| c.insert(p, t)        | 在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器 |
| c.emplace(p, args)    |                                                              |
| c.insert(p, n, t)     | 在迭代器p指向的元素之前插入一个n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p |
| c.insert(p, b, e)     | 将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器；若范围为空，则返回p |
| c.insert(p, il)       | il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回p |

- `forward_list`有自己专有版本的`insert`和`emplace`
- `forward_list`不支持`push_back`和`emplace_back`
- `vector`和`string`不支持`push_front`和`emplace_front`

将元素插入到`vector`、`deque`和`string`中的任何位置都是合法的，然而，这样做可能很耗时。

