# 第九章 顺序容器

## 9.1 顺序容器概述

| 类型         | 功能                                                         |
| ------------ | ------------------------------------------------------------ |
| vector       | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 |
| deque        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快      |
| list         | 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快 |
| forward_list | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 |
| array        | 固定大小数组。支持快速随机访问。不能添加或删除元素           |
| string       | 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 |

选择容器的基本原则：

1. 除非你有更好的理由选择其他容器，否则应使用`vector`。
2. 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`。
3. 如果要求随机访问元素，应使用`vector`或`deque`。
4. 如果程序需要在头尾位置插入或删除元素，但不会在中间的位置插入或删除操作，则使用`deque`。
5. 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素则
   - 首先，确定是否真的需要在容器中间位置添加元素。当处理数据时，通常很容易地向`vector`追加数据，然后再调用标准库的`sort`函数。
   - 如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中。

如果不确定应该使用哪种容器，那么可以在程序中只使用`vector`和`list`公共操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用`vector`或`list`都很方便。



## 9.2 容器库概览

| 类型别名        |                                                        |
| --------------- | ------------------------------------------------------ |
| iterator        | 此容器类型的迭代器                                     |
| const_iterator  | 可以读取元素，但不能修改元素的迭代器类型               |
| size_type       | 无符号整数类型，足够保存此类容器类型最大可能容器的大小 |
| difference_type | 带符号整数类型，足够保存两个迭代器之间的距离           |
| value_type      | 元素类型                                               |
| reference       | 元素左值类型，与value_type&含义相同                    |
| const_reference | 元素的const左值类型，(即，const value_type&)           |



| 构造函数        |                                                         |
| --------------- | ------------------------------------------------------- |
| C c             | 默认构造函数，构造空容器                                |
| C c1(c2)        | 构造c2的拷贝c1                                          |
| C c(b, e)       | 构造c，将迭代器b和e指定的范围内元素拷贝到c(array不支持) |
| C c{a, b, c...} | 列表初始化c                                             |



| 赋值与swap        |                              |
| ----------------- | ---------------------------- |
| c1=c2             | 将c1中的元素替换为c2中元素   |
| c1 = {a, b, c...} | 将c1中的元素替换为列表中元素 |
| a.swap(b)         | 交换a和b的元素               |
| swap(a, b)        | 与a.swap(b)等价              |



| 大小         |                                          |
| ------------ | ---------------------------------------- |
| c.size()     | c中元素的数目(不支持forward_list)        |
| c.max_size() | c可保存的最大元素数目                    |
| c.empty()    | 若c中存储了元素，返回false，否则返回true |



| 添加/删除元素(不适用与array) | 注：在不同容器中，这些操作的接口都不同 |
| ---------------------------- | -------------------------------------- |
| c.insert(args)               | 将args中的元素拷贝进c                  |
| c.emplace(inits)             | 使用inits构造c中的一个元素             |
| c.erase(args)                | 删除args指定的元素                     |
| c.clear()                    | 删除c中的所有元素，返回void            |
| 关系运算符                   |                                        |
| ==, !=                       | 所有容器都支持相等(不等)运算符         |
| <, <=, >, >=                 | 关系运算符(无序关联容器不支持)         |



| 获取迭代器             |                                           |
| ---------------------- | ----------------------------------------- |
| c.begin(), c.end()     | 返回指向c的首元素和尾元素之后位置的迭代器 |
| c.cbegin(), c.cend()   | 返回const_iterator                        |
| 反向容器的额外成员     | 不支持forward_list                        |
| reverse_iterator       | 按逆序寻址元素的迭代器                    |
| const_reverse_iterator | 不能修改元素的逆序迭代器                  |
| c.rbegin(), c.rend()   | 返回指向c的尾元素和首元素之前位置的迭代器 |
| c.crbegin(), c.crend() | 返回const_reverse_iterator                |

### 迭代器

左闭右开

