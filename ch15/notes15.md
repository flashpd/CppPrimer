# 第15章 面向对象程序设计

## 15.1 OOP：概述

面向对象程序设计的核心思想是数据抽象、继承和动态绑定。

- 通过使用数据抽象，我们可以将类的接口与实现分离
- 使用继承，可以定义相似的类型并对其相似关系建模
- 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象

**继承**

- 通过继承关系在一起的类构成一种层次体系，在层次关系的根部**基类**
- 继承得到的类被称为**派生类**
- 积累负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的数据
- 对于某些函数，基类希望它的派生类自定义适合自己的版本，此时积累就将这些函数声明成**虚函数**
- 派生类必须通过使用**类派生列表**明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符

```cpp
class Quote
{
public:
    string isbn() const;
    virtual double net_price(size_t n) const;
};

class Bulk_quote : public Quote
{
public:
    double net_price(size_t) const override;
};
```

- 派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数前加上`virtual`关键字，但这不是必须的。`C++11`新标准允许派生类显式地注明它将使用哪个成员函数改写基类地虚函数，具体措施是在该函数地形参列表后增加一个`override`关键字。



**动态绑定**

- 使用同一段代码可以分别处理基类和派生类的对象
- 函数的运行版本由实参决定，即运行时选择函数的版本



## 15.2 定义基类和派生类

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

### 定义基类

- 任何构造函数之外的非静态函数都可以是虚函数。关键字`virtual`只能出现在类内部的声明语句之前而不能用于类外部的函数定义

- 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。

**成员函数与继承**

- 一种是基类希望其派生类进行覆盖的函数
- 另一种是基类希望派生类之间继承不需要改变的函数

- 对于前者，基类通常将其定义为虚函数。当我们使用指针或引用调用虚函数时，该调用将被动态绑定



**访问控制与继承**

- `protected`：基类、派生类、友元可以访问
- `private`：只有基类本身和友元可以访问

### 定义派生类

- 派生类必须通过使用**类派生列表**明确它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：`public`、`protected`或者`private`
- C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个`override`关键字。
- 派生类的声明：声明中不包含它的派生列表。
- 派生类构造函数：派生类必须使用基类的构造函数去初始化它的基类部分。
- 静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。
- `C++11`新标准提供了一种防止继承的方法，在类名后面跟一个关键字`final`

**派生类对象及派生类向基类的类型转换**

```cpp
Quote item;       // 基类对象
Bulk_quote bulk;  // 派生类对象
Quote *p = &item; // p指向Quote对象
p = &bulk;        // p指向bulk的Quote部分
Quote &r = bulk;  // r绑定到bulk的Quote部分
```

**派生类的声明**

派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表

```cpp
class Bulk_quote : public Quote; // 错误：派生类列表不能出现在这里
class Bulk_quote;                //正确：声明派生类的正确方式
```

每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又含有其他基类的成员；以此类推直至继承链的顶端，因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

**防止继承的发生**

为了防止继承的发生的方法，即在类名后跟一个关键字`final`



## 15.3 虚函数

- 使用虚函数可以实现动态绑定
- `OOP`的核心思想是多态
- 当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同
- 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数前加`virtual`关键字，也可以不加
- `C++`新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表后加一个`override`关键字。
- 如果我们想覆盖某个虚函数，但不小心把形参列表错了，这个时候就不会覆盖基类中的虚函数。加上`override`可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。
- 如果虚函数使用默认实参。则基类和派生类中定义的默认实参最好一致。
- 通常，只有成员函数（或友元）中的代码才需要使用作用域运算符（`::`）来回避虚函数的机制。



## 15.4 抽象基类

- **纯虚函数**：无需定义，只用在函数体的位置（即在声明语句的分号之前）书写`=0`就可以将一个虚函数说明为纯虚函数。`=0`只能出现在类内部的虚函数声明语句处。
- **抽象基类**：含有纯虚函数的类是抽象基类