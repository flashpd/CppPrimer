# 第15章 面向对象程序设计

## 15.1 OOP：概述

面向对象程序设计的核心思想是数据抽象、继承和动态绑定。

- 通过使用数据抽象，我们可以将类的接口与实现分离
- 使用继承，可以定义相似的类型并对其相似关系建模
- 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象

**继承**

- 通过继承关系在一起的类构成一种层次体系，在层次关系的根部**基类**
- 继承得到的类被称为**派生类**
- 积累负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的数据
- 对于某些函数，基类希望它的派生类自定义适合自己的版本，此时积累就将这些函数声明成**虚函数**
- 派生类必须通过使用**类派生列表**明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符

```cpp
class Quote
{
public:
    string isbn() const;
    virtual double net_price(size_t n) const;
};

class Bulk_quote : public Quote
{
public:
    double net_price(size_t) const override;
};
```

- 派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数前加上`virtual`关键字，但这不是必须的。`C++11`新标准允许派生类显式地注明它将使用哪个成员函数改写基类地虚函数，具体措施是在该函数地形参列表后增加一个`override`关键字。



**动态绑定**

- 使用同一段代码可以分别处理基类和派生类的对象
- 函数的运行版本由实参决定，即运行时选择函数的版本



## 15.2 定义基类和派生类

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

### 定义基类

- 任何构造函数之外的非静态函数都可以是虚函数。关键字`virtual`只能出现在类内部的声明语句之前而不能用于类外部的函数定义

- 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。

**成员函数与继承**

- 一种是基类希望其派生类进行覆盖的函数
- 另一种是基类希望派生类之间继承不需要改变的函数

- 对于前者，基类通常将其定义为虚函数。当我们使用指针或引用调用虚函数时，该调用将被动态绑定



**访问控制与继承**

- `protected`：基类、派生类、友元可以访问
- `private`：只有基类本身和友元可以访问

### 定义派生类

- 派生类必须通过使用**类派生列表**明确它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：`public`、`protected`或者`private`
- C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个`override`关键字。
- 派生类的声明：声明中不包含它的派生列表。
- 派生类构造函数：派生类必须使用基类的构造函数去初始化它的基类部分。
- 静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。
- `C++11`新标准提供了一种防止继承的方法，在类名后面跟一个关键字`final`

**派生类对象及派生类向基类的类型转换**

```cpp
Quote item;       // 基类对象
Bulk_quote bulk;  // 派生类对象
Quote *p = &item; // p指向Quote对象
p = &bulk;        // p指向bulk的Quote部分
Quote &r = bulk;  // r绑定到bulk的Quote部分
```

**派生类的声明**

派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表

```cpp
class Bulk_quote : public Quote; // 错误：派生类列表不能出现在这里
class Bulk_quote;                //正确：声明派生类的正确方式
```

每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又含有其他基类的成员；以此类推直至继承链的顶端，因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

**防止继承的发生**

为了防止继承的发生的方法，即在类名后跟一个关键字`final`

### 类型转换与继承

**理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在**

当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真是类型。该对象可能是基类的对象，也可能是派生类的对象。

**静态类型和动态类型**

- 表达式的静态类型在编译时总是已知的，它是变量在声明时的类型或表达式生成的类型。
- 动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。、
- 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。
- 基类的指针或引用的静态类型可能与其动态类型不一致。

## 15.3 虚函数

- 使用虚函数可以实现动态绑定
- `OOP`的核心思想是多态
- 当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同
- 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数前加`virtual`关键字，也可以不加
- `C++`新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表后加一个`override`关键字。
- 如果我们想覆盖某个虚函数，但不小心把形参列表错了，这个时候就不会覆盖基类中的虚函数。加上`override`可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。
- 如果虚函数使用默认实参。则基类和派生类中定义的默认实参最好一致。
- 通常，只有成员函数（或友元）中的代码才需要使用作用域运算符（`::`）来回避虚函数的机制。



## 15.4 抽象基类

- **纯虚函数**：无需定义，只用在函数体的位置（即在声明语句的分号之前）书写`=0`就可以将一个虚函数说明为纯虚函数。`=0`只能出现在类内部的虚函数声明语句处。
- **抽象基类**：含有纯虚函数的类是抽象基类
- 抽象基类负责定义接口，而后续的其他类可以覆盖该接口
- 我们不能（直接）创建一个抽象基类的对象

**派生类构造函数只直接初始化它的直接基类**（书本541页有栗子）

**关键概念：重构**

重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。

## 15.5 访问控制与继承

**友元与继承**：友元关系既不能传递也不能继承

**改变个别成员的可访问性**

- 需要改变派生类继承的某个名字的访问级别时，可以使用`using`声明
- 派生类只能为那些它可以访问的名字提供`using`声明



## 15.6 继承中的类作用域

**名字冲突与继承**

- 派生类的成员将隐藏同名的基类成员
- 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字
- 可以通过作用域运算符来使用一个被隐藏的基类成员

**名字查找先于类型查找**

- 定义在派生类中的函数也不会重载其基类中的成员
- 如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员
- 及时派生类成员和基类成员的形参列表不一致，基类成员也仍会被隐藏掉



## 15.7 构造函数与拷贝控制

### 虚析构函数

如果基类的析构函数不是虚函数，则`delete`一个指向派生类对象的基类指针将产生未定义的行为。

```cpp
class Quote
{
public:
    // 如果我们删除的是一个指向派生类对象的基类指针 则需要虚析构函数
    virtual ~Quote() = default; // 动态绑定析构函数
};
```

```cpp
Quote *itemP = new Quote; // 静态类型和动态类型一致
delete itemP;             // 调用Quote的析构函数
itemP = new Bulk_quote;   // 静态类型与动态类型不一致
delete itemP;             // 调用Bulk_quote的析构函数
```

之前曾经介绍，如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法由此推断出该基类还需要赋值运算符或拷贝构造函数。（552页）







**留个坑，实在是学不动了。**

